# 正则表达式与模式匹配

## 定义正则表达式

1. 一对包在(/)内的字符  例如

   ``` javascript
   let pattern = /s$/; // 匹配以s结尾的字符
   ```

2. 字符多数由字幕数字组成    /s$/i 加上 i 表示不区分大小写

   

#### 字符字面量

 1. \反斜杠转义可以匹配不是字母的字符 如: \n 匹配换行字面量

 2. 具有特殊含义的字符: ^ $ . * + ? = ! : | \ / ( ) [ ] { }

 3. 不惧特殊含义的则仍旧匹配自身 如: @...

    

#### 字符类

1. 把字符放进[ ]内就可以组成字符类 例如: 

   ```javascript
   /[abc]/  // 字符类匹配括号内任意字符 匹配: a, b, c 中任意字母
   ```

2. (^) 排除性字符

   ```javascript
   /[^abc]/ // 匹配 a, b, c 外任意字母
   ```

   ```javascript
   /[a-z]/ // 匹配a-z 全部小写字符
   ```



##### 正则表达式字符类

| **字符** | **匹配目标**                                |
| -------- | ------------------------------------------- |
| [...]    | 方括号内的任意一个字符                      |
| [^...]   | 不在方括号内的任意一个字符                  |
| \w       | 任意ASCII单词字符。等价于[a-zA-Z0-9_]       |
| \W       | 任意非ASCII单词字符。等价于[  ^a-zA-Z0-9_ ] |
| \s       | 任意Unicode空白字符                         |
| \S       | 任意非Unicode空白字符                       |
| \d       | 任意ASCII数字字符。等价于[0-9]              |
| \D       | 任意非ASCII数字字符。等于[ ^0-9]            |
| [\b]     | 退格字符和字面量(特例)                      |



#### 重复

| **字符** | **含义**                                                  |
| -------- | --------------------------------------------------------- |
| {n, m}   | 匹配前项至少n次, 但不超过m次                              |
| {n, }    | 匹配前项n次或更多次                                       |
| {n}      | 匹配前项恰好n次                                           |
| ?        | 匹配前项0次或1次。 换句话说, 前项是可选的。 等价于 {0, 1} |
| +        | 匹配前项一次或者多次。 等价于 {1, }                       |
| *        | 匹配前项0次或多次。 等价于 {0, }                          |

##### 示例

```javascript
let r = /\d{2, 4}/; // 匹配2到4位数数字
r = /\w{3}\d?/;     // 匹配3个字母后跟1个可选的数字
r = /\s+java\s+/;  // 匹配"java"且前后有一个或多个空格
r = /[^(]*/;      // 匹配一个或多个非开始圆括号的字符
```



#### 非贪婪重复

1. 后面加上一个(?) 进行非贪婪匹配

   

#### 任选、分组和引用

1. 任选: 用(|) 把表达式分开  |  从左到有匹配

   ```javascript
   /ab|cd|ef/; //匹配字符串"ab"、"cd" 或 "ef"
   ```

   

2. ( ) 可以用来定义*__子表达式__* (分组)             可用(\\) 字符加上数字*__引用__*子表达式匹配的文本 补充: 按照左括号的顺序来匹配

3. 如果不想某个子表达式被引用 可以在子表达式开头加上(?:) 这样引用就会忽视他的存在而去引用下一个子表达式

   ```javascript
   /([Jj]ava(?:[Ss]cript)\sis\s(fun\w*)/  // 使用引用\2 匹配到的是(fun\w*)
   ```

   

##### 正则表达式任选、分组和引用字符

| 字符        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| \| | 任选: 可以匹配左侧的子表达式, 也可以匹配右侧的子表达式 |
| (...)       | 分组: 将模式分组为单元 方便使用*、+、?、\|等。同时记住分组匹配的字符，方便后面的引用中使用 |
| (**?:**...) | 仅分组: 将模式分组为单元，但不记住分组的匹配字符             |
| \n          | 匹配与第n个分组匹配的的相同字符。从左往右计数匹配 (?: 开头的分组不计数 |



#### 指定匹配位置

##### 正则表达式锚点字符

| **字符** | **含义**                                                     |
| -------- | ------------------------------------------------------------ |
| ^        | 匹配字符串开头, 或者在使用m标志时, 匹配一行的开头            |
| $        | 匹配字符串末尾, 或者在使用m标志时, 匹配一行的末尾            |
| \b       | 匹配单词边界。换句话说，匹配\w字符和\W字符之间或者\w与字符串开头或者末尾之间的位置  (但要注意[\b]匹配退格字符) |
| \B       | 匹配非单词边界的位置                                         |
| (?=p)    | 肯定式向前断言。要求后面的字符匹配模式p，但匹配结果不包含与之匹配的字符 |
| (?!p)    | 否定式向前断言。要求后面的字符不匹配模式p                    |
| (?<=)    | 肯定式向后断言。                                             |
| (?<!)    | 否定式向后断言                                               |

单词边界解释:   单词边界断言检查字符串中的当前位置是否为单词边界。单词边界是指下一个字符是单词，而上一个字符不是单词，反之亦然。

<!--一张表很难看出什么 若想不起来 可查看犀牛书263页 或者MDN搜素(很多关于正则表达式的没有中文 只有英文原版)-->



##### 标志

*JavaScrit 有六个标志 每一个标志都有一个字母表示 放在第二个斜杠后面 或者在RegExp构造函数要以字符串形式作为第二参数*

1. g => 表示 "全局性的"(global) 找到字符串中包含的所以匹配项
2. i => 表示模式匹配应该不区分大小写
3. m => 表示应该 "多行" 模式进行匹配 
4. s => 与m类似 
5. u => u代表Unicode 可以让正则匹配完整的码点 巴拉巴拉 反正建议都要使用它
6. y => **看不懂 打个标记 找空补上**





---

---





## 模式匹配的字符串方法

**_接下来介绍正则表达式的语法及RegExp对象相关的API_**

String支持四个正则表达式的方法

**search()**

=>接收一个正则表达式参数, 返回第一个匹配项起点字符的位置 如果没找到 则返回 -1

​	如果方法参数不是正则表达式, 他会先把这个参数传给RegExp()构造函数

​	search()方法不支持全局搜索 so 你使用g标志会被忽略 ;

```javascript
"JavaScipt".search(/script/ui)   // => 4
"Python".search(/script/ui)   // => -1
```



**replace()**

=> 接收正则表达式为第一个参数, 字符串为第二个参数

​	搜素调用的字符串 寻找匹配的文本

​	带g标志会替换所以匹配项 反之则only替换第一个

​	如果第一个参数是字符串 不会转换(like search methord) 而是直接搜素;

````javascript
text.replace(/javascript/gi, "JavaScript");

let quote = /"([^"]*)"/g;
'He said "stop"'.replace(quote, '<$1>'); // 'He said <stop>' 
// 上述示例曾给我带来迷惑 现在对其进行解释
// replace()方法会及那个$加数字(如上文的$1)替换为子表达式的文本(即( )内匹配的内容)
// 所以此代码匹配" "然后匹配子表达式 将$1当成子表达式的匹配内容 然后用<$1> 替换 "stop"
````

